# Algorithm analysis course, BMSTU IU7, V semester, 2022


## **Lection 4, 22.09.11**

Есть матрица n на n из 0 и 1, в ней есть один или несколько (ладно, пусть 1) квадрат наибольшего размера, состоящий из 1
Найти наибольший квадрат из единиц за один обход по матрице - координаты и размер
Матрицу можно (!) портить, меняя значения внутри. Можно просматривать k фиксированных соседей

### Терминология
1. Вход алгоритма - D.

    D = (cli | i = 1, m; |cli| = beta бит)
2. Длина входа

    n (как правило n != |D| = m)

    n = mu_t(D)

    Т - умнжоение матриц nxn,

    m = 2n^2 + 1,

    mu_T(D) = n = sqrt((|D| - 1) / 2) - так исторически слоожилось
3. D_n - сколько наборов входных данных при определённой длине входа

    D_n = {D | mu_T(D) = n}

    Если beta = 16, n = 10

    |D_10| = 2^(16^10)

4. Универсальные характеристики

    V(D) = V_D(D) + V_R(D) + V_доп(D) + V_exe, где

        V_D - объём начальных данных;

        V_R - объём возвращаемых данных;

        V_доп -  объём дополнительных данных;

        V_exe - объём данных под программу

    f_A(D) - трудоёмкости - число элементарных операций принятой модели вычислений, заданных
5. f_A(n)

    a) f_{A}^{V}(n) equiv (by def) = min_{D in D_n} {f_A(D)} - лучший случай

    b) f_{A}^{^}(n) equiv (by def) = max_{D in D_n}{f_A(D)} - худший случай

        forall D in D_n f_A(D) <= f_{A}^{^}(n)
    c) Страшная и безполезная формула - взять фотку у Лёши Авсюнина - формула мат.ожидания и того, что средняя трудоёмкость это сумма трудоёмкостей, умноженных на их мат.ожидания

**Пример:** Суммирование элементов массива Sum(A, n ; S)
```
 s <- 0
 for i <- 1 to n
    s <- s + A[i]
```
Ууууу, что такое цикл? Переписать надо
```
next:
    i <- 1
    ...
    i <- i + 1
    if i <= n goto(next)
```

f_{A}^{^}(n) =f_{A}^{V} = f_{A}(n) = 1 + 1 + n(3 + 3) = 6n + 2
Задача: можно ли не 6n, а меньше?

**Пример 2** Умножение матриц Mult.Matr(A, B, n; C)
```
Mult.Matr(A, B, n; C)
    for i <- to n
        for j <- to n
            s <- 0
            for k <- to n
                s <- s + A[i, k] * B[k, j]
                C[i, j] <- s
```
f_A(n) = 1 + n(3 + 1 + n(3 + 1 + 1 + n(3 + 7) + 3)) = 10n^3 + 8n^2 + 4n + 1
