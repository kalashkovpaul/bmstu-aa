\chapter{Аналитическая часть}
В этом разделе будет представлена информация о многопоточности, а также теоретически описан паттерн thread pool, реализация которого будет распараллелена в данной лабораторной работе. 

\section{Многопоточность}
\textbf{Многопоточность}~\cite{multithreading} \text{(англ. \textit{multithreading})}-- это способность центрального процессора (ЦП) обеспечивать одновременное выполнение нескольких потоков в рамках использования ресурсов одного процессора. Поток -- последовательность инструкций, которые могут исполняться параллельно с другими потоками одного и того же породившего их процесса.

Процессом~\cite{process} называют программу в ходе своего выполнения. Таким образом, когда запускается программа или приложение, создаётся процесс. Один процесс может состоять из одного или больше потоков.
Таким образом, поток является сегментом процесса, сущностью, которая выполняет задачи, стоящие перед исполняемым приложением. 
Процесс завершается тогда, когда все его потоки заканчивают работу.
Каждый поток в операционной системе является задачей, которую должен выполнить процессор. Сейчас большинство процессоров умеют выполнять несколько задач на одном ядре, создавая дополнительные, виртуальные ядра, или же имеют несколько физических ядер. Такие процессоры нызываются многоядерными. 

При написании программы, использующей несколько потоков, следует учесть, что при последовательном запуске потоков и передаче управления исполняемому потоку не получится раскрыть весь потенциал многопоточности, т.к. большинство потоков будут существовать без дела.
Необходимо создавать потоки для независимых, отнимающих много времени функций, и выполнять их параллельно, тем самым сокращая общее время выполнения процесса.


Одной из проблем, встающих при использовании потоков, является проблема совместного доступа к информации. Фундаментальным ограничением является запрет на запись из двух и более потоков в одну ячейку памяти одновременно.

Из того следует, что необходим примитив синхронизации обращения к данным -- так называемый мьютекс \text{(англ. \textit{mutex -- mutual exclusion})}. 
Он может быть захвачен для работы в монопольном режиме или освобождён. 
Так, если 2 потока одновременно пытаются захватить мьютекс, успевает только один, а другой будет ждать освобождения. 

Набор инструкций, выполняемых между захватом и освобождением мьютекса, называется \textit{критической секцией}. 
Поскольку в то время, пока мьютекс захвачен, остальные потоки, требующие выполнения критической секции, ждут освобождения мьютекса, требуется разрабатывать программное обеспечение таким образом, чтобы критическая секция была минимальной.

\section{Паттерн thread pool}
\textbf{Thread pool}~\cite{thread-pool}	 -- архитектурный паттерн, предназначенный для достижения параллельности выполнения программы. 
Основная идея данного паттерна заключается в том, чтобы создавать набор (пул) потоков, из которого в случае появления задачи, которую можно выполнить параллельно с другими потоками, берётся поток.
Задача выполняется в рамках забранного потока и после завершения освобождённый поток возвращается в пул.

Согласно поставленной задаче, реализации сервера для раздачи статической информации, можно сделать вывод, что задачами, которые можно выполнять параллельно, являются задачи обработки запроса. Поступившие запросы необходимо синхронно записывать в очередь запросов, после чего распределять задачи по имеющимся потокам.

\section{Требования к программе}
Выделен ряд требований к программе:
\begin{itemize}[label=---]
	\item сервер должен работать на локальном доменном имени на порту 8080;
	\item обращение к серверу происходит посредством браузера, запросы --- по протоколу HTTP1.1;
	\item в ответ должен отдаваться статический файл, указанный в предыдущем пункте.
\end{itemize}

\section*{Вывод}
В данной работе необходимо реализовать сервер раздачи статической информации с использованием архитектурного паттерна thread pool, а также провести сравнение времени обработки установленного количества запросов при использовании различного числа потоков. Требуется, чтобы сервер умел отдавать информацию различного типа и размера, в том числе полноценные статические страницы, директории, вложенные файлы, а также пустые запросы.